<!DOCTYPE HTML>
<html>
<head>
  <style>
    /* Estilo de pantalla completa y fondo negro */
    html, body {
      width:  100%;
      height: 100%;
      margin: 0px;
      border: 0;
      overflow: hidden; 
      display: block;   
      background-color: black; 
      font-family: 'Segoe UI', sans-serif;
    }
    
    #webglcanvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Menú Flotante */
    #opciones {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: rgba(40, 40, 40, 0.85); 
      color: #eee;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #555;
      width: 200px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.5);
      backdrop-filter: blur(5px);
    }

    h3 { margin-top: 0; margin-bottom: 15px; font-size: 1rem; text-align: center; border-bottom: 1px solid #666; padding-bottom: 8px; color: #fff;}
    label { display: block; margin-top: 12px; font-size: 0.8rem; color: #bbb; font-weight: 600;}
    select, input, button { width: 100%; margin-top: 5px; background: #333; color: white; border: 1px solid #555; padding: 6px; border-radius: 4px; font-size: 0.9rem;}
    select:focus, input:focus { outline: none; border-color: #007bff; }
    button { cursor: pointer; background-color: #0066cc; border: none; font-weight: bold; margin-top: 20px; transition: background-color 0.2s;}
    button:hover { background-color: #0055aa; }
    .hint { font-size: 0.7rem; color: #888; text-align: center; margin-top: 10px; font-style: italic;}
  </style>    
  <title>Auto Low Poly Detallado - WebGL 2.0</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
</head>
<body>

  <canvas id="webglcanvas"></canvas>

  <div id="opciones">
    <h3>Auto Mejorado</h3>
    
    <label>Estilo Visual:</label>
    <select id="estiloVisual">
        <option value="solido">Sólido (Original)</option>
        <option value="malla">Malla (Wireframe)</option>
        <option value="puntos">Puntos</option>
    </select>

    <label>Tinte (Filtro de Color):</label>
    <input type="color" id="colorTinte" value="#ffffff">

    <label>Tamaño (Escala):</label>
    <input type="range" id="escalaSlider" min="0.2" max="2.5" step="0.1" value="1.0">

    <button id="reset">Reiniciar Cámara</button>
    <p class="hint">Click izquierdo + arrastrar para rotar</p>
  </div>

  <script id="vs" type="vertex">
    #version 300 es
    uniform mat4 uMatrizProyeccion;
    uniform mat4 uMatrizVista;
    uniform mat4 uMatrizModelo;
    layout(location = 0) in vec3 aVertices;
    layout(location = 1) in vec4 aColores;
    out vec4 vColores;
    void main() {
      vColores = aColores;  
      gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 1.0);
      gl_PointSize = 5.0;
    }
  </script>

  <script id="fs" type="fragment">
    #version 300 es
    precision highp float;
    in vec4 vColores;
    uniform vec4 uColorTinte;
    out vec4 color;
    void main() {
        color = vColores * uColorTinte;
    }
  </script>
  
  <script>
    "use strict";

    /* Variables globales */
    let canvas;
    let programaID;
    let gl;
    let autoObjeto;
    let arcBall;

    /* Variables Uniformes */
    let uMatrizProyeccion;
    let uMatrizVista;
    let uMatrizModelo;
    let uColorTinte;

    /* Matrices */
    let MatrizProyeccion = new Array(16);
    let MatrizVista = new Array(16);
    let MatrizModelo = new Array(16);

    /* Para la interacción */
    let tx = 0, ty = 0;
    let sx = 1, sy = 1, sz = 1;
    let MatrizRotacion = new Array(16);
    let Matriz = new Array(16);
    let boton_izq_presionado = false;
    let boton_der_presionado = false;

    /***************************************************************************/
    /* Se crean, compilan y enlazan los programas Shader                       */
    /***************************************************************************/
    function compilaEnlazaLosShaders() {
      let shaderDeVertice = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(shaderDeVertice, document.getElementById("vs").text.trim());
      gl.compileShader(shaderDeVertice);
      if (!gl.getShaderParameter(shaderDeVertice, gl.COMPILE_STATUS)) {
         console.error(gl.getShaderInfoLog(shaderDeVere));
      }

      let shaderDeFragmento = gl.createShader(gl.FRAGM_SHADER);
      gl.shaderSource(shaderDeFragmento, document.getEentById("fs").text.trim());
      gl.compileShader(shaderDeFragmento);
      if (!gl.getShaderParameter(shaderDeFragmento, glMPILE_STATUS)) {
         console.error(gl.getShaderInfoLog(shaderDeFranto));
      }

      programaID = gl.createProgram();
      gl.attachShader(programaID, shaderDeVertice); 
      gl.attachShader(programaID, shaderDeFragmento);
      gl.linkProgram(programaID);
      if (!gl.getProgramParameter(programaID, gl.LINK_STATUS)) {
         console.error(gl.getProgramInfoLog(programaID));
      }

      gl.useProgram(programaID);
    }

    /***************************************************************************/
    /* Transformaciones mediante matrices                                      */
    /***************************************************************************/

    function toRadians(grados) {
      return grados * Math.PI / 180;
    };

    function identidad(r) {
      r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = 0;
      r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = 0;
      r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
    }

    function traslacion(matriz, tx, ty, tz) {
      let r = new Array(16);
      r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = tx;
      r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = ty;
      r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] =  1;
      multiplica(matriz, matriz, r);
    }

    function escalacion(matriz, sx, sy, sz) { 
      let r = new Array(16);
      r[0] = sx; r[4] =  0; r[ 8] =  0; r[12] =  0;
      r[1] =  0; r[5] = sy; r[ 9] =  0; r[13] =  0;
      r[2] =  0; r[6] =  0; r[10] = sz; r[14] =  0;
      r[3] =  0; r[7] =  0; r[11] =  0; r[15] =  1;
      multiplica(matriz, matriz, r);
    }

    function rotacionX(matriz, theta){
      let r = new Array(16);
      let c = Math.cos(toRadians(theta));
      let s = Math.sin(toRadians(theta));
      r[0] =  1; r[4] =  0; r[ 8] =  0; r[12] = 0;
      r[1] =  0; r[5] =  c; r[ 9] = -s; r[13] = 0;
      r[2] =  0; r[6] =  s; r[10] =  c; r[14] = 0;
      r[3] =  0; r[7] =  0; r[11] =  0; r[15] = 1;
      multiplica(matriz, matriz, r); 
    }

    function rotacionY(matriz, theta){
      let r = new Array(16);
      let c = Math.cos(toRadians(theta));
      let s = Math.sin(toRadians(theta));
      r[0] =  c; r[4] =  0; r[ 8] =  s; r[12] = 0;
      r[1] =  0; r[5] =  1; r[ 9] =  0; r[13] = 0;
      r[2] = -s; r[6] =  0; r[10] =  c; r[14] = 0;
      r[3] =  0; r[7] =  0; r[11] =  0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    function rotacionZ(matriz, theta){
      let r = new Array(16);
      let c = Math.cos(toRadians(theta));
      let s = Math.sin(toRadians(theta));
      r[0] =  c; r[4] = -s; r[ 8] =  0; r[12] = 0;
      r[1] =  s; r[5] =  c; r[ 9] =  0; r[13] = 0;
      r[2] =  0; r[6] =  0; r[10] =  1; r[14] = 0;
      r[3] =  0; r[7] =  0; r[11] =  0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    function ortho(r, izq, der, abj, arr, cerca, lejos) {
      r[0] = 2/(der - izq); r[4] =             0; r[ 8] =                  0; r[12] =         -(der + izq)/(der - izq);
      r[1] =             0; r[5] = 2/(arr - abj); r[ 9] =                  0; r[13] =         -(arr + abj)/(arr - abj);
      r[2] =             0; r[6] =             0; r[10] = -2/(lejos - cerca); r[14] = -(lejos + cerca)/(lejos - cerca);
      r[3] =             0; r[7] =             0; r[11] =                  0; r[15] =                               1;
    }

    function frustum(r, izq, der, abj, arr, cerca, lejos) {
      r[0] = 2*cerca/(der-izq); r[4] =                 0; r[ 8] =          (der+izq)/(der-izq); r[12] =                            0;
      r[1] =                 0; r[5] = 2*cerca/(arr-abj); r[ 9] =          (arr+abj)/(arr-abj); r[13] =                            0;
      r[2] =                 0; r[6] =                 0; r[10] = -(lejos+cerca)/(lejos-cerca); r[14] = -2*lejos*cerca/(lejos-cerca);
      r[3] =                 0; r[7] =                 0; r[11] =                           -1; r[15] =                            0;
    }

    function perspective(r, fovy, aspecto, cerca, lejos) {
      let ang = fovy * 0.5;
      let f = (Math.abs(Math.sin(toRadians(ang))) < 1e-8 ? 0 : 1) / Math.tan(toRadians(ang));
      r[0] = f/aspecto; r[4] = 0; r[ 8] =                                  0; r[12] =                                 0;
      r[1] =         0; r[5] = f; r[ 9] =                                  0; r[13] =                                 0;
      r[2] =         0; r[6] = 0; r[10] = -(lejos + cerca) / (lejos - cerca); r[14] =  -2.0 * lejos * cerca / (lejos - cerca);
      r[3] =         0; r[7] = 0; r[11] =                              - 1.0; r[15] =                                 0;
    }

    function multiplica(c, a, b) {
      let r = new Array(16);
      let i, j, k;
      for (i = 0; i < 4; i++){
        for (j = 0; j < 4; j++){
          let s = 0;
          for (k = 0; k < 4; k++)
            s = s + a[i + k * 4] * b[k + j * 4];
            r[i + j * 4] = s;
          }
        }
      for (i = 0; i < 16; i++)
        c[i] = r[i];
    }

    /* Función auxiliar para color Hex a RGB */
    function hexToRgba(hex){
        let r=parseInt(hex.slice(1,3),16)/255;
        let g=parseInt(hex.slice(3,5),16)/255;
        let b=parseInt(hex.slice(5,7),16)/255;
        return [r,g,b,1];
    }

    /***************************************************************************/
    /* La Clase Vector3                                                        */
    /***************************************************************************/

    class Vector3 {
      constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
      }
      mas(v2) {
        return (new Vector3(this.x + v2.x, this.y + v2.y, this.z + v2.z));
      }
      menos(v2) {
        return (new Vector3(this.x - v2.x, this.y - v2.y, this.z - v2.z));
      }
      producto_vectorial(v2) {
        let r = new Vector3();
        r.x = (this.y * v2.z) - (this.z * v2.y);
        r.y = (this.z * v2.x) - (this.x * v2.z);
        r.z = (this.x * v2.y) - (this.y * v2.x);
        return r;
      }
      producto_escalar(v2) {
        return (this.x * v2.x) + (this.y * v2.y) + (this.z * v2.z);
      }
      longitud() {
        return (Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z));
      }
      normaliza() {
        let l = this.longitud();
        if (l > 0 ) {
          this.x = this.x / l;
          this.y = this.y / l;
          this.z = this.z / l;
        }
      }
      normal(v1, v2, v3) {
        let u = new Vector3(); 
        let v = new Vector3(); 
        let n = new Vector3(); 
        u = v2.menos(v1);
        v = v3.menos(v1);
        n = u.producto_vectorial(v);
        n.normaliza();
        return n;
      }
      toString() {
        return "Vector3 [x=" + this.x + ", y=" + this.y + ", z=" + this.z + "]";
      }
    }

    /***************************************************************************/
    /* ArcBall: Obtiene los vectores U y V de la esfera                        */
    /***************************************************************************/

    let Punto2f = function(x, y) {
      this.x = x;
      this.y = y;
    }

    class ArcBall {
      constructor(w, h) {
        this.Epsilon = 1.0e-5;
        this.U = new Vector3();
        this.V = new Vector3();
        this.ajusta(w, h);
      }
      ajusta(w, h) {
        if (!((w > 1.0) && (h > 1.0)))
          document.write("ERROR");
        this.ajustaAncho = 2.0 / (w - 1.0);
        this.ajustaAlto = 2.0 / (h - 1.0);
      }
      obtieneVector(vector, x, y) {
        let temp = new Punto2f(x, y);
        temp.x = (temp.x * this.ajustaAncho) - 1.0;
        temp.y = 1.0 - (temp.y * this.ajustaAlto);
        let longitud2 = (temp.x * temp.x) + (temp.y * temp.y);
        if (longitud2 > 1.0) {
          let norma = (1.0 / Math.sqrt(longitud2));
          vector.x = temp.x * norma;
          vector.y = temp.y * norma;
          vector.z = 0.0;
        } else { 
          vector.x = temp.x;
          vector.y = temp.y;
          vector.z = Math.sqrt(1.0 - longitud2);
        }
      }
      primerPunto(x, y) {
        this.obtieneVector(this.U, x, y);
      }
      segundoPunto(x, y) {
        let q = new Cuaternion();
        this.obtieneVector(this.V, x, y);
        if (q != null) {
          let Normal = this.U.producto_vectorial(this.V);
          if (Normal.longitud() > this.Epsilon) { 
            q.x = Normal.x;
            q.y = Normal.y;
            q.z = Normal.z;
            q.w = this.U.producto_escalar(this.V);
          } else { 
            q.x = q.y = q.z = q.w = 0.0;
          }
        }
        return q;
      }
    }

    /***************************************************************************/
    /* Cuaternion: Realiza las operaciones de los cuaterniones.                */
    /***************************************************************************/

    class Cuaternion {
      constructor(w, x, y, z) {
        this.w = w;
        this.x = x;
        this.y = y;
        this.z = z;
      }
      inicializa(w, v) {
        this.w = w;
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
      }
      norma2() {
        return (this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
      }
      conjugado() {
        x = -this.x;
        y = -this.y;
        z = -this.z;
        return this;
      }
      multiplica(a, b) {
        let q = new Cuaternion(0,0,0,0);
        q.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;
        q.x = a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y;
        q.y = a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x;
        q.z = a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w;
        return q;
      }
      multiplica_escalar(a, b) {
        let q = new Cuaternion(0,0,0,0);
        q.w = a.w * b;
        q.x = a.x * b;
        q.y = a.y * b;
        q.z = a.z * b;
        return q;
      }
      rota(q, p) { 
        let p_homogeneo = new Cuaternion(0, 0, 0, 0);
        p_homogeneo.inicializa(0, p);
        let p_prima = this.multiplica(q, this.multiplica(p_homogeneo, q.inverso()));
        return (new Vector3(p_prima.x, p_prima.y, p_prima.z));
      }
      rota1(q, p) { 
        let p_homogeneo = new Cuaternion(0, 0, 0, 0);
        p_homogeneo.inicializa(0, p);
        let p_prima = this.multiplica(q, this.multiplica(p_homogeneo, q.conjugado()));
        return (new Vector3(p_prima.x, p_prima.y, p_prima.z));
      }
      inverso() {
        let q = new Cuaternion(0,0,0,0);
        let n = this.norma2();
        if (n <= 1e-8)
          document.write("INVERSO: Error");
        q = multiplica_escalar(new Cuaternion(this.w, -this.x, -this.y, -this.z), 1 / n);
        return q;
      }
      static rota2(a, q) {
        let d, s;
        d = (q.x * q.x) + (q.y * q.y) + (q.z * q.z) + (q.w * q.w);
        s = (d > 0.0) ? (2.0 / d) : 0.0;
        a[0] =  1.0 - (q.y*q.y + q.z*q.z) * s; a[4] =        (q.x*q.y - q.w*q.z) * s; a[8]  =        (q.x*q.z + q.w*q.y) * s; a[12] = 0;
        a[1] =        (q.x*q.y + q.w*q.z) * s; a[5] = 1.0  - (q.x*q.x + q.z*q.z) * s; a[9]  =        (q.y*q.z - q.w*q.x) * s; a[13] = 0;
        a[2] =        (q.x*q.z - q.w*q.y) * s; a[6] =        (q.y*q.z + q.w*q.x) * s; a[10] = 1.0  - (q.x*q.x + q.y*q.y) * s; a[14] = 0;
        a[3] =                              0; a[7] =                              0; a[11] =                              0; a[15] = 1;
      }
      toString() {
        return "Cuaternion [w=" + this.w + ", x=" + this.x + ", y=" + this.y + ", z=" + this.z + "]";
      }
    }

    /***********************************************************************************/
    /* Se define la geometría y se almacenan en los buffers de memoria y se renderiza. */
    /***********************************************************************************/
    class AutoLowPolyDetallado {
      constructor(gl) {
        let vertices = [];
        let colores = []; 
        let indices = [];
        let indexOffset = 0;

        function agregarParte(cx, cy, cz, w, h, d, r, g, b) {
            let x = w/2, y = h/2, z = d/2;
            let v = [
              cx-x, cy-y, cz+z,  cx+x, cy-y, cz+z,  cx+x, cy+y, cz+z,  cx-x, cy+y, cz+z, // Frente
              cx-x, cy+y, cz-z,  cx+x, cy+y, cz-z,  cx+x, cy-y, cz-z,  cx-x, cy-y, cz-z, // Atrás
              cx-x, cy-y, cz-z,  cx-x, cy-y, cz+z,  cx-x, cy+y, cz+z,  cx-x, cy+y, cz-z, // Izq
              cx+x, cy-y, cz+z,  cx+x, cy-y, cz-z,  cx+x, cy+y, cz-z,  cx+x, cy+y, cz+z, // Der
              cx-x, cy-y, cz-z,  cx+x, cy-y, cz-z,  cx+x, cy-y, cz+z,  cx-x, cy-y, cz+z, // Abajo
              cx-x, cy+y, cz+z,  cx+x, cy+y, cz+z,  cx+x, cy+y, cz-z,  cx-x, cy+y, cz-z  // Arriba
            ];
            let i = [0,1,2,0,2,3, 4,5,6,4,6,7, 8,9,10,8,10,11, 12,13,14,12,14,15, 16,17,18,16,18,19, 20,21,22,20,22,23];
            
            vertices.push(...v);
            for(let k=0; k<24; k++) colores.push(r, g, b, 1.0); 
            for(let k=0; k<i.length; k++) indices.push(i[k] + indexOffset);
            indexOffset += 24;
        }

        const cChasis=[0.2, 0.2, 0.2], cParachoques=[0.4, 0.4, 0.4];
        const cCarroceria=[0.85, 0.1, 0.1]; 
        const cPuerta=[0.75, 0.05, 0.05];   
        const cCabina=[0.1, 0.1, 0.35], cTecho=[0.85, 0.1, 0.1]; 
        const cNeumatico=[0.1, 0.1, 0.1], cAro=[0.9, 0.9, 0.9]; 
        const cFarosDel=[1.0, 1.0, 0.8], cFarosTras=[0.9, 0.0, 0.0];

        agregarParte(0, -0.3, 0,      4.0, 0.4, 2.0, ...cChasis);
        agregarParte(2.1, -0.3, 0,    0.2, 0.45, 2.1, ...cParachoques);
        agregarParte(-2.1, -0.3, 0,   0.2, 0.45, 2.1, ...cParachoques);
        
        agregarParte(0, 0.3, 0,       3.9, 0.8, 1.95, ...cCarroceria); 
        agregarParte(2.0, 0.3, 0,     0.1, 0.6, 1.2, ...cChasis);   

        let puertaAncho = 1.4;
        let puertaAlto = 0.65;
        let puertaGrosor = 2.05; 
        agregarParte(-0.2, 0.3, 0,   puertaAncho, puertaAlto, puertaGrosor, ...cPuerta);

        agregarParte(-0.4, 1.0, 0,    2.0, 0.7, 1.7, ...cCabina);
        
        agregarParte(-0.4, 1.4, 0,    1.6, 0.15, 1.4, ...cTecho);

        let wx = 1.3, wy = -0.4, wz = 1.05;
        let sRueda = 0.85; 
        let sAro = 0.5;    
        let profRueda = 0.5;
        let profAro = 0.55; 

        let crearRueda = (x, y, z) => {
            agregarParte(x, y, z, sRueda, sRueda, profRueda, ...cNeumatico);
            let zAro = (z > 0) ? z + 0.05 : z - 0.05; 
            agregarParte(x, y, z, sAro, sAro, profAro, ...cAro);
        };

        crearRueda(wx, wy, wz);       
        crearRueda(wx, wy, -wz);      
        crearRueda(-wx*1.3, wy, wz);  
        crearRueda(-wx*1.3, wy, -wz); 
        
        agregarParte(0.4, 0.9, 1.0,  0.25, 0.2, 0.3, ...cCarroceria); 
        agregarParte(0.4, 0.9, -1.0, 0.25, 0.2, 0.3, ...cCarroceria); 

        agregarParte(1.98, 0.4, 0.65,  0.1, 0.25, 0.35, ...cFarosDel);
        agregarParte(1.98, 0.4, -0.65, 0.1, 0.25, 0.35, ...cFarosDel);
        agregarParte(-1.98, 0.4, 0.65, 0.1, 0.25, 0.35, ...cFarosTras);
        agregarParte(-1.98, 0.4, -0.65, 0.1, 0.25, 0.35, ...cFarosTras);

        this.autoVAO = gl.createVertexArray();
        gl.bindVertexArray(this.autoVAO);
        
        let codigoVertices = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

        let codigoColores = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, codigoColores);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

        let codigoDeIndices = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, codigoDeIndices);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
        
        this.numIndices = indices.length;
        gl.bindVertexArray(null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      }
      dibuja(gl, modo) {
        gl.bindVertexArray(this.autoVAO);
        gl.drawElements(modo, this.numIndices, gl.UNSIGNED_SHORT, 0);
        gl.bindVertexArray(null);
      }
    }

    /***************************************************************************/
    /* Eventos del Ratón                                                       */
    /***************************************************************************/

    function mouseDown(event) {
      let posx = new Number();
      let posy = new Number();

      if (event.x != undefined && event.y != undefined) {
        posx = event.x;
        posy = event.y;
      } else {
        posx = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
        posy = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;
      }

      posx = posx - canvas.offsetLeft;
      posy = posy - canvas.offsetTop;

      if (event.button == 0){ 
        Matriz = MatrizRotacion.slice(); 
        arcBall.primerPunto(posx, posy);
        boton_izq_presionado = true;
      } else if (event.button == 2) 
        boton_der_presionado = true;

      return false;
    };

    function mouseUp(e){
      boton_izq_presionado = false;
      boton_der_presionado = false;
    };

    function mouseMove(event) {
      let posx = new Number();
      let posy = new Number();

      if (event.x != undefined && event.y != undefined) {
        posx = event.x;
        posy = event.y;
      } else {
        posx = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
        posy = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;
      }

      posx = posx - canvas.offsetLeft;
      posy = posy - canvas.offsetTop;

      if (boton_izq_presionado) {
        let q = arcBall.segundoPunto(posx, posy);
        Cuaternion.rota2(MatrizRotacion, q);
        multiplica(MatrizRotacion, MatrizRotacion, Matriz);
      } else if (boton_der_presionado){
        posx = (posx * 10 / canvas.width) - 5;
        posy = (10 - posy * 10 / canvas.height) - 5;
        tx = posx;
        ty = posy;
      }
    };

    function zoom(event) {
      event.preventDefault();
      if (event.deltaY > 0){
        sx = sx * 0.9;
        sy = sy * 0.9;
        sz = sz * 0.9;
      } else {
        sx = sx * 1.1;
        sy = sy * 1.1;
        sz = sz * 1.1;
      }  
    };

    function actualizarProyeccion() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
        arcBall.ajusta(canvas.width, canvas.height);
        let aspecto = canvas.width / canvas.height;
        ortho(MatrizProyeccion, -6 * aspecto, 6 * aspecto, -6, 6, -20, 20);
        gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);
    }

    function dibuja() {
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      identidad(MatrizModelo);
      traslacion(MatrizModelo, tx, ty, 0);
      
      let escalaInput = parseFloat(document.getElementById("escalaSlider").value);
      let scaleTotal = escalaInput;
      escalacion(MatrizModelo, scaleTotal, scaleTotal, scaleTotal); 
      
      rotacionX(MatrizModelo, 15); 
      rotacionY(MatrizModelo, -35);

      multiplica(MatrizModelo, MatrizModelo, MatrizRotacion);
      gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

      let colorHex = document.getElementById("colorTinte").value;
      let r = parseInt(colorHex.slice(1,3),16)/255;
      let g = parseInt(colorHex.slice(3,5),16)/255;
      let b = parseInt(colorHex.slice(5,7),16)/255;
      gl.uniform4fv(uColorTinte, [r,g,b,1]);

      let estilo = document.getElementById("estiloVisual").value;
      let modoGL = (estilo === "malla") ? gl.LINES : (estilo === "puntos" ? gl.POINTS : gl.TRIANGLES);

      autoObjeto.dibuja(gl, modoGL);
      
      requestAnimationFrame(dibuja);
    }

    function reinicia() {
      tx = 0; ty = 0;
      sx = 1, sy = 1, sz = 1;
      identidad(MatrizRotacion);
      document.getElementById("escalaSlider").value = 1.0;
      document.getElementById("colorTinte").value = "#ffffff";
      document.getElementById("estiloVisual").value = "solido";
      dibuja();
    }

    function main() {
      canvas = document.getElementById("webglcanvas");
      gl = canvas.getContext("webgl2");
      if (!gl) {
         document.write("WebGL 2.0 no está disponible en tu navegador");
         return;
      }
      canvas.addEventListener("mousedown", mouseDown, false);
      canvas.addEventListener("mouseup", mouseUp, false);
      canvas.addEventListener("mouseout", mouseUp, false);
      canvas.addEventListener("mousemove", mouseMove, false);
      document.getElementById("reset").onclick = reinicia;
      canvas.addEventListener("wheel", zoom, { passive: false });
      window.addEventListener("resize", actualizarProyeccion);
      
      compilaEnlazaLosShaders();

      autoObjeto = new AutoLowPolyDetallado(gl);
      arcBall = new ArcBall(window.innerWidth, window.innerHeight);

      gl.useProgram(programaID);
      uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
      uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
      uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");
      uColorTinte = gl.getUniformLocation(programaID, "uColorTinte");
      
      identidad(MatrizVista);
      gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);
      identidad(MatrizRotacion);
      
      actualizarProyeccion();

      gl.enable(gl.DEPTH_TEST);
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      dibuja();
    }
    window.onload = main;
  </script>
</body>
</html>
